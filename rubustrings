#!/usr/bin/env ruby

# Rubustrings
# A format validator for Localizable.strings files.
# The MIT License (MIT) Copyright (c) 2014 @dcordero
# https://github.com/dcordero/Rubustrings

%w[colored].each do |this_gem|
  begin
    require this_gem
  rescue LoadError
    abort "Please install the '#{this_gem}' gem."
  end
end

module Enumerable
  def stable_sort
    sort_by.with_index { |x, idx| [x, idx] }
  end

  def stable_sort_by
    sort_by.with_index { |x, idx| [yield(x), idx] }
  end
end

def open_and_read_file(file_name)
  File.open(file_name, 'rb:utf-16:utf-8').read if File.exist?(file_name)
end

def remove_comments_and_empty_lines(file_data)
  multiline_comments_regex = /\/\*.*?\*\//m
  empty_lines_regex = /^$\n/

  file_data.gsub(multiline_comments_regex, "").gsub(empty_lines_regex, "") if file_data
end

def validate_format(line)
  localizable_strings_format_regex = /^\"((?:\\.|[^\\"])*?)\"\s=\s\"((?:\\.|[^\\"])*?)\";/
  match = localizable_strings_format_regex.match line
end

def validate_special_characters(translation_key, translation_value)
  # Remove %% to avoid ambiguous scenarios with adjacent formats like "%s%%s"
  translation_key = translation_key.gsub("%%", " ")
  translation_value = translation_value.gsub("%%", " ")

  variables_regex = /\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?(hh|ll|[hlLzjt])?([b-fiosuxX@])/
  position_index = 0
  length_index = 7
  format_index = 8

  # sort by according to parameter field, if specified
  key_variables = translation_key.scan(variables_regex).stable_sort_by{ |r| r[position_index].to_i }
  value_variables = translation_value.scan(variables_regex).stable_sort_by{ |r| r[position_index].to_i }

  return true unless key_variables.any? || value_variables.any?
  return false unless key_variables.count == value_variables.count

  # we should not have any parameter fields in the keys
  return false unless key_variables.last[position_index] == nil

  # if we do have parameter fields, we need to include all of them
  if value_variables[0][position_index] != nil
    return false unless value_variables.last[position_index] != nil
    validation_result = true
    value_variables.each_with_index { |v, idx|
      if v[position_index].to_i != idx + 1
        validation_result = false
      end
    }
    return false unless validation_result
  else
    return false unless value_variables.last[position_index] == nil
  end

  # remove parameter field
  key_variables = key_variables.map{ |v| [v[length_index], v[format_index]] }
  value_variables = value_variables.map{ |v| [v[length_index], v[format_index]] }
  return key_variables == value_variables
end

def validate_special_beginning(translation_key, translation_value)
  beginning_regex = /^(?:\s|\n|\r)/

  return true unless translation_key =~ beginning_regex || translation_value =~ beginning_regex
  translation_key.chars.first == translation_value.chars.first
end

def validate_special_ending(translation_key, translation_value)
  ending_regex = /(?:\s|\n|\r)$/

  return true unless translation_key =~ ending_regex || translation_value =~ ending_regex
  translation_key.chars.last == translation_value.chars.last
end

def check_translation_length(translation_key, translation_value)
  translation_value.length / translation_key.length < 3
end

def validate_translation_line(line)
  match = validate_format line
  return print "✘ Error, invalid format: #{line}".red unless match

  print "⊗ Warning, no translated string: #{line}".yellow unless match[2].length > 0

  print "⊗ Warning, translation significantly large: #{line}".yellow unless check_translation_length match[1], match[2]

  validation_special_characters = validate_special_characters match[1],match[2]
  print "✘ Error, variables mismatch: #{line}".red unless validation_special_characters

  validation_special_beginning = validate_special_beginning match[1],match[2]
  print "✘ Error, beginning mismatch: #{line}".red unless validation_special_beginning

  validation_special_ending = validate_special_ending match[1],match[2]
  print "✘ Error, ending mismatch: #{line}".red unless validation_special_ending

  return validation_special_characters && validation_special_beginning && validation_special_ending
end

def validate_localizable_string_file (file_name)
  file_data = open_and_read_file file_name
  cleaned_strings = remove_comments_and_empty_lines file_data

  return puts "✘ Error, no translations found in file: #{file_name}".red if cleaned_strings.empty?

  validation_result = true
  cleaned_strings.each_line do |line|
    validation_result &= validate_translation_line line
  end
  return validation_result
end

abort "No strings file provided" if ARGV.empty?
ARGV.each do |file_name| 
  puts "Processing file: \"#{file_name}\"\n".blue
  result = validate_localizable_string_file file_name

  if result
    puts "\nResult: ✓ Strings file validated succesfully".bold.green
    exit 0
  else 
    puts "\nResult: ✘ Some errors detected".bold.red
    exit 1
  end
end 
